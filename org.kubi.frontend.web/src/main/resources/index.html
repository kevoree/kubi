<!DOCTYPE html>
<html>
<head>
    <script src="http://code.jquery.com/jquery-1.11.2.min.js"></script>
    <script src="nunjucks.js"></script>
    <script src="org.kubi.model-all.js"></script>
    <script src="org.kevoree.modeling.database.websocket.WebSocket.js"></script>
    <script src="./canvasjs.min.js"></script>
</head>
<body>
<script id="ecosystem-template" type="text/x-handlebars-template">
    <h1>EcoSystem {{ecosystem.name}}</h1>
    <div class="body">
        <ul>
            {% asyncEach device in ecosystem.devices %}
            <li>{{device.name}} ({{device.version}})
                <ul>
                    {% asyncEach ff in device.functions %}
                    <li>
                        <button onclick="javascript:btclick('{{ff.now()}}','{{ff.uuid()}}','sayHello');">
                            {{ff.name}}
                        </button>
                    </li>
                    {% endeach %}
                </ul>
                <ul>
                    {% asyncEach param in device.parameters %}

                    <li>
                        <p>
                            {{param.name}}  -  {{param.value}}
                        </p>
                    </li>
                    {% endeach %}
                </ul>
            </li>
            {% endeach %}
        </ul>
        {{body}}
    </div>
</script>
<div id="ecosystem"></div>
<div id="chartContainer"></div>
<div id="execution-result"></div>
<script>
    var last_timestamp = (new Date()).getTime();
    var kubiModel = new org.kubi.KubiModel();
    function btclick(time, uuid, params) {
        kubiModel.universe(0).time(time).lookup(uuid).then(function (resolved) {
            resolved.exec(params, function (rpcRes) {
                $("#execution-result").html("Model based RPC result=" + rpcRes);
            });
        })
    }
    kubiModel.setContentDeliveryDriver(new org.kevoree.modeling.database.websocket.WebSocketClient("ws://" + location.host + "/cdn"));
    kubiModel.connect().then(function (e) {
        if (e) {
            console.error(e);
        } else {
            initGraph();
        }
    });
</script>

<script>
 var chart;

 var dataPoints = {};

 function initGraph(){
     chart = new CanvasJS.Chart("chartContainer",
             {
                 width: 1000,
                 height: 500,
                 title: {
                     text: "graph of the occupation of the parking(%) depending of the time(hour)"
                 },
                 axisX: {
                     valueFormatString: "HH:mm:ss",
                     interval: 3600,
                     intervalType: "second",
                     labelFontColor: "black",
                     lineColor: "black",
                     lineThickness: 1,
                     tickColor: "black",
                     tickLength: 5,
                     tickThickness: 1
                 },
                 axisY: {
                     title: "% frequency",
                     titleFontColor: "black",
                     lineColor: "black",
                     lineThickness: 1,
                     gridColor: "black",
                     gridThickness: 1,
                     labelFontColor: "black",
                     tickColor: "black",
                     tickLength: 5,
                     tickThickness: 1
                 },
                 legend: {
                     verticalAlign: "bottom",
                     horizontalAlign: "center",
                     fontSize: 16
                 },
                 toolTip: {
                     shared: true
                 },
                 data: []
             }
        );

     var currentView = kubiModel.universe(0).time(last_timestamp);

     currentView.getRoot().then(function (root) {
         root.traversal().traverse(org.kubi.meta.MetaEcosystem.REF_DEVICES).done().then(function (devices){
             var d;
             for(d = 0; d< devices.length; d++)
             {
                 var device = devices[d];
                 // add a curb describing the device on the chart
                 chart.options.data.push({type: "line", showInLegend: true, name: device.getName(), dataPoints: []});
                 dataPoints[device.getName()]=[];
                 // add old data to the chart
                 device.traversal().traverse(org.kubi.meta.MetaDevice.REF_PARAMETERS).withAttribute(org.kubi.meta.MetaParameter.ATT_NAME, "name").done().then(function (params){
                     if (params.length != 0) {
                         var param = params[0];
                         param.jump(param.now()-1000).then(function (paramTimed){
                             param.parent().then(function (parent){
                                 // TODO : gÃ©rer mieux l'ajout
                                 addPreviousValues(paramTimed, parent.getName());
                             });
                         });
                     }
                 });
             }
         });
         /*root.traversal().traverse(org.kubi.meta.MetaEcosystem.REF_DEVICES).withAttribute(org.kubi.meta.MetaDevice.ATT_NAME, "echo2")
             .traverse(org.kubi.meta.MetaDevice.REF_PARAMETERS).withAttribute(org.kubi.meta.MetaParameter.ATT_NAME, "name").done().then(function (params) {
                 if (params.length != 0) {
                     var param = params[0];
                     param.jump(param.now()-1000).then(function (paramTimed){
                         addPreviousValues(paramTimed);
                     });
                 }
                 });*/
     });
 }

 /**
  * TODO : mettre un truc avec plus de trucs dedans ([{name, dataPoint},{name, dataPoint}]
  **/
 function addPreviousValues(paramTimed, deviceName){
     console.log("--", deviceName);
     if((paramTimed.now() > last_timestamp-30000) && (paramTimed.getValue()!= undefined)) {
         dataPoints[deviceName].push({x: new Date(paramTimed.now()), y: parseFloat(paramTimed.getValue())});
         console.log("---------",dataPoints);
         //addDataPointWithSerie({x: new Date(paramTimed.now()), y: parseFloat(paramTimed.getValue())}, deviceName);
         paramTimed.jump(paramTimed.now() - 1000).then(function (param1){
             addPreviousValues(param1, deviceName);
         });
     }
     else{
         var unsortedDataPoints = dataPoints[deviceName];
         var sortedDataPoints = [];
         for(var i=0;i<unsortedDataPoints.length;i++){
             sortedDataPoints.push(unsortedDataPoints.slice(unsortedDataPoints.length-i-1,unsortedDataPoints.length-i)[0])
         }

         addDataPointsWithSerieName(sortedDataPoints,deviceName);
         initPage();
         chart.render();
     }
 }

 function addDataPoints(values) {
     for(var serie in values) {
         var dpts = values[serie];
         var dpsCollection = chart.options.data[serie].dataPoints;
         for(var point in dpts) {
             dpsCollection.push(dpts[point]);
             if(dpsCollection.length > this.windowSize) {
                 dpsCollection.shift();
             }
         }
     }
     this.chart.render();
 }

 /**
  *Add a set of points to the chart in the data set number serieNumber
  *@param  value the set of points
  * @param serieNumber the number of the serie that you want to add the points
  * [
  *     {x: new Date(timestamp), y: Float_value},
  *     {x: new Date(timestamp), y: Float_value}
  * ]
  **/
 function addDataPointsWithSerieNumber(values, serieNumber) {
     var dpsCollection = chart.options.data[serieNumber].dataPoints;
     for(var point in values) {
         dpsCollection.push(values[point]);
         if(dpsCollection.length > this.windowSize) {
             dpsCollection.shift();
         }
     }
     this.chart.render();
 }

 /**
  *Add a set of points to the chart
  * @param  value the set of poins
  * @param serieName the name of the serie that you want to add the points
  * [
  *     {x: new Date(timestamp), y: Float_value},
  *     {x: new Date(timestamp), y: Float_value}
  * ]
  **/
 function addDataPointsWithSerieName(values, serieName) {
     var dpsCollection;
     var index;
     for(var d in chart.options.data){
         data = chart.options.data[d];
         if(data.name.equals(serieName)){
             dpsCollection = data.dataPoints;
             index = d;
         }
     }
     if(dpsCollection != null && index != null) {
         for (var point in values) {
             dpsCollection.push(values[point]);
             if (dpsCollection.length > this.windowSize) {
                 dpsCollection.shift();
             }
         }
     }
     else{
         console.error("Bad series name ",serieName, " : device not in the data set of the chart.");
     }
     this.chart.render();
 }

 /**
  * Add the point to the chart in the first set of data
  * @param point
  * {x: new Date(timestamp), y: Float_value}
  */
    function addDataPoint(point) {
        var dpsCollection = chart.options.data[0].dataPoints;
        dpsCollection.push(point);
        if(dpsCollection.length > this.windowSize) {
            dpsCollection.shift();
        }
        this.chart.render();
    }


 /**
  * Add the point to the chart
  * @param point
  * {x: new Date(timestamp), y: Float_value}
  * @param serie name
  *     the name of the chart where you want to add the point (should be the name of the device)
  */
 function addDataPointWithSerie(point, serie) {
     console.log("In dataPOintWithSerie .....",serie);
     var dpsCollection;
     var index;
     for(var i in chart.options.data){
         data = chart.options.data[i];
         if(data.name.equals(serie)){
             dpsCollection = data.dataPoints;
             index=i;
         }
     }
     if(dpsCollection != null && index!=null) {
         var dpsCollection = chart.options.data[index].dataPoints;
         dpsCollection.push(point);
         if (dpsCollection.length > this.windowSize) {
             dpsCollection.shift();
         }
     }
     else{
         console.error("Bad series name (=",serie ,") : device not in the data set of the chart.");
     }
     this.chart.render();
 }

 function initPage(){
        var currentView = kubiModel.universe(0).time(last_timestamp);
        currentView.getRoot().then(function (root) {
            nunjucks.configure({autoescape: true});
            try {
                // init the graph

                nunjucks.renderString($("#ecosystem-template").html(), {ecosystem: root,autoRefresh:true,autoNow:true}, function (err, res) {
                    if (err) {
                        console.log(err);
                    }
                    $("#ecosystem").html(res);
                    var currentView = kubiModel.universe(0).time((new Date()).getTime());
                    currentView.getRoot().then(function (root) {
                        root.traversal().traverse(org.kubi.meta.MetaEcosystem.REF_DEVICES).done().then(function (devices){
                            var d;
                           for(d = 0; d<devices.length ; d++){
                               var device = devices[d];
                               device.traversal().traverse(org.kubi.meta.MetaDevice.REF_PARAMETERS).withAttribute(org.kubi.meta.MetaParameter.ATT_NAME, "name").done().then(function (params) {
                                   var param = params[0];
                                   param.parent().then(function(parent){
                                       addDataPointWithSerie({x: new Date(param.now()), y: parseFloat(param.getValue())}, parent.getName());
                                   });
                               });
                           }
                        });

                    });
                });
            } catch(e){
                console.error(e);
            }
        });
    }

</script>
</body>
</html>