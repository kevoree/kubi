<!DOCTYPE html>
<html>
<head>
    <script src="http://code.jquery.com/jquery-1.11.2.min.js"></script>
    <script src="nunjucks.js"></script>
    <script src="org.kubi.model-all.js"></script>
    <script src="org.kevoree.modeling.database.websocket.WebSocket.js"></script>
    <script src="./canvasjs.min.js"></script>
</head>
<body>
<script id="ecosystem-template" type="text/x-handlebars-template">
    <h1>EcoSystem {{ecosystem.name}}</h1>
    <div class="body">
        <ul>
            {% asyncEach device in ecosystem.devices %}
            <li>{{device.name}} ({{device.version}})
                <ul>
                    {% asyncEach ff in device.functions %}
                    <li>
                        <button onclick="javascript:btclick('{{ff.now()}}','{{ff.uuid()}}','sayHello');">
                            {{ff.name}}
                        </button>
                    </li>
                    {% endeach %}
                </ul>
                <ul>
                    {% asyncEach param in device.parameters %}

                    <li>
                        <p>
                            {{param.name}}  -  {{param.value}}
                        </p>
                    </li>
                    {% endeach %}
                </ul>
            </li>
            {% endeach %}
        </ul>
        {{body}}
    </div>
</script>
<div id="ecosystem"></div>
<div id="chartContainer"></div>
<div id="execution-result"></div>
<script>
    var last_timestamp = (new Date()).getTime();
    var kubiModel = new org.kubi.KubiModel();
    function btclick(time, uuid, params) {
        kubiModel.universe(0).time(time).lookup(uuid).then(function (resolved) {
            resolved.exec(params, function (rpcRes) {
                $("#execution-result").html("Model based RPC result=" + rpcRes);
            });
        })
    }
    kubiModel.setContentDeliveryDriver(new org.kevoree.modeling.database.websocket.WebSocketClient("ws://" + location.host + "/cdn"));
    kubiModel.connect().then(function (e) {
        if (e) {
            console.error(e);
        } else {
            var currentView = kubiModel.universe(0).time(last_timestamp);
            currentView.getRoot().then(function (root) {
                nunjucks.configure({autoescape: true});
                try {
                    // init the graph
                    init();
                    nunjucks.renderString($("#ecosystem-template").html(), {ecosystem: root,autoRefresh:true,autoNow:true}, function (err, res) {
                        if (err) {
                            console.log(err);
                        }
                        $("#ecosystem").html(res);
                        var currentView = kubiModel.universe(0).time((new Date()).getTime());
                        currentView.getRoot().then(function (root) {
                            root.traversal().traverse(org.kubi.meta.MetaEcosystem.REF_DEVICES).withAttribute(org.kubi.meta.MetaDevice.ATT_NAME, "echo2")
                                .traverse(org.kubi.meta.MetaDevice.REF_PARAMETERS).withAttribute(org.kubi.meta.MetaParameter.ATT_NAME, "name").done().then(function (params) {
                                    var param = params[0];
                                    console.log(param.getValue());

                                    addDataPoint({x: new Date(param.now()), y: parseFloat(param.getValue())});

                                    console.log(chart.options.data[0].dataPoints);
                                });
                        });
                    });
                } catch(e){
                    console.error(e);
                }



            });
        }
    });
</script>

<script>
 var chart;

 function init(){
     chart = new CanvasJS.Chart("chartContainer",
             {
                 width: 800,
                 height: 500,
                 title: {
                     text: "toto"
                 },
                 axisX: {
                     valueFormatString: "HH:mm",
                     interval: 3600,
                     intervalType: "second",
                     labelFontColor: "black",
                     lineColor: "black",
                     lineThickness: 1,
                     tickColor: "black",
                     tickLength: 5,
                     tickThickness: 1
                 },
                 axisY: {
                     title: "% frequency",
                     titleFontColor: "black",
                     lineColor: "black",
                     lineThickness: 1,
                     gridColor: "black",
                     gridThickness: 1,
                     labelFontColor: "black",
                     tickColor: "black",
                     tickLength: 5,
                     tickThickness: 1
                 },
                 legend: {
                     verticalAlign: "bottom",
                     horizontalAlign: "center",
                     fontSize: 16
                 },
                 toolTip: {
                     shared: true
                 },
                 data: [{
                     type: "stackedArea",
                     showInLegend: true,
                     name: "Instantaneous consumption",
                     dataPoints: []
                 }]
             }
        );

     var currentView = kubiModel.universe(0).time((new Date()).getTime());
     currentView.getRoot().then(function (root) {
         root.traversal().traverse(org.kubi.meta.MetaEcosystem.REF_DEVICES).withAttribute(org.kubi.meta.MetaDevice.ATT_NAME, "echo2")
             .traverse(org.kubi.meta.MetaDevice.REF_PARAMETERS).withAttribute(org.kubi.meta.MetaParameter.ATT_NAME, "name").done().then(function (params) {
                if (params.length() != 0) {
                    var param = params[0];
                    var dataPoints;
                    var i = 100;
                    while(i>0){
                        i++;
                        param.jump(param.now()-10000).then(function (){
                            dataPoints.push({x: new Date(param.now()), y: parseFloat(param.getValue())});

                        });
                    }
                    addDataPoints(dataPoints);
                }
             });
     });

     chart.render();
 }



    function addDataPoints(values) {
        for(var serie in values) {
            var dpts = values[serie];
            var dpsCollection = chart.options.data[serie].dataPoints;
            //console.log(dpsCollection.length);
            for(var point in dpts) {
                dpsCollection.push(dpts[point]);
                if(dpsCollection.length > this.windowSize) {
                    dpsCollection.shift();
                }
            }
        }
        this.chart.render();
    }

    function addDataPoint(point) {
        var dpsCollection = chart.options.data[0].dataPoints;
        dpsCollection.push(point);
        if(dpsCollection.length > this.windowSize) {
            dpsCollection.shift();
        }
        this.chart.render();
    }
</script>
</body>
</html>