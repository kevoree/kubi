<!DOCTYPE html>
<html>
<head>
    <script src="http://code.jquery.com/jquery-1.11.2.min.js"></script>
    <script src="nunjucks.js"></script>
    <script src="org.kubi.model-all.js"></script>
    <script src="org.kevoree.modeling.database.websocket.WebSocket.js"></script>
    <script src="./canvasjs.min.js"></script>
</head>
<body>
<script id="ecosystem-template" type="text/x-handlebars-template">
    <h1>EcoSystem {{ecosystem.name}}</h1>
    <div class="body">
        <ul>
            {% asyncEach device in ecosystem.devices %}
            <li>{{device.name}} ({{device.version}})
                <ul>
                    {% asyncEach ff in device.functions %}
                    <li>
                        <button onclick="javascript:btclick('{{ff.now()}}','{{ff.uuid()}}','sayHello');">
                            {{ff.name}}
                        </button>
                    </li>
                    {% endeach %}
                </ul>
                <ul>
                    {% asyncEach param in device.parameters %}

                    <li>
                        <p>
                            {{param.name}}  -  {{param.value}}
                        </p>
                    </li>
                    {% endeach %}
                </ul>
            </li>
            {% endeach %}
        </ul>
        {{body}}
    </div>
</script>
<div id="ecosystem"></div>
<div id="chartContainer"></div>
<div id="execution-result"></div>
<script>
    var last_timestamp = (new Date()).getTime();
    var kubiModel = new org.kubi.KubiModel();
    function btclick(time, uuid, params) {
        kubiModel.universe(0).time(time).lookup(uuid).then(function (resolved) {
            resolved.exec(params, function (rpcRes) {
                $("#execution-result").html("Model based RPC result=" + rpcRes);
            });
        })
    }
    kubiModel.setContentDeliveryDriver(new org.kevoree.modeling.database.websocket.WebSocketClient("ws://" + location.host + "/cdn"));
    kubiModel.connect().then(function (e) {
        if (e) {
            console.error(e);
        } else {
            initGraph();
        }
    });
</script>

<script>
 var chart;

 function initGraph(){
     chart = new CanvasJS.Chart("chartContainer",
             {
                 width: 1000,
                 height: 500,
                 title: {
                     text: "grah of the occupation of the parking(%) depending of the time(hour)"
                 },
                 axisX: {
                     valueFormatString: "HH:mm:ss",
                     interval: 3600,
                     intervalType: "second",
                     labelFontColor: "black",
                     lineColor: "black",
                     lineThickness: 1,
                     tickColor: "black",
                     tickLength: 5,
                     tickThickness: 1
                 },
                 axisY: {
                     title: "% frequency",
                     titleFontColor: "black",
                     lineColor: "black",
                     lineThickness: 1,
                     gridColor: "black",
                     gridThickness: 1,
                     labelFontColor: "black",
                     tickColor: "black",
                     tickLength: 5,
                     tickThickness: 1
                 },
                 legend: {
                     verticalAlign: "bottom",
                     horizontalAlign: "center",
                     fontSize: 16
                 },
                 toolTip: {
                     shared: true
                 },
                 data: [{
                     type: "line",
                     showInLegend: true,
                     name: "Parking occupation",
                     dataPoints: []
                 }]
             }
        );

     var currentView = kubiModel.universe(0).time(last_timestamp);

     currentView.getRoot().then(function (root) {
         root.traversal().traverse(org.kubi.meta.MetaEcosystem.REF_DEVICES).withAttribute(org.kubi.meta.MetaDevice.ATT_NAME, "echo2")
             .traverse(org.kubi.meta.MetaDevice.REF_PARAMETERS).withAttribute(org.kubi.meta.MetaParameter.ATT_NAME, "name").done().then(function (params) {
                if (params.length != 0) {
                    var param = params[0];
                    param.jump(param.now()-1000).then(function (paramTimed){
                        addPreviousValues(paramTimed);
                    });
                }
             });
     });
 }

 var dataPoints = [];
 function addPreviousValues(paramTimed){
     if((paramTimed.now() > last_timestamp-30000) && (paramTimed.getValue()!= undefined)) {
         dataPoints.push({x: new Date(paramTimed.now()), y: parseFloat(paramTimed.getValue())});

         paramTimed.jump(paramTimed.now() - 1000).then(function (param1){
             addPreviousValues(param1);
         });
     }
     else{
         var sortedDataPoints = [];
         for(var i=0;i<dataPoints.length;i++){
             sortedDataPoints.push(dataPoints.slice(dataPoints.length-i-1,dataPoints.length-i)[0])
         }
         addDataPointsWithSerieNumber(sortedDataPoints,0);
         initPage();
         chart.render();
     }
 }

 function addDataPoints(values) {
     for(var serie in values) {
         var dpts = values[serie];
         var dpsCollection = chart.options.data[serie].dataPoints;
         for(var point in dpts) {
             dpsCollection.push(dpts[point]);
             if(dpsCollection.length > this.windowSize) {
                 dpsCollection.shift();
             }
         }
     }
     this.chart.render();
 }

 /**
  *Add a set of points to the chart
  *@param  value the set of poins
  * @param serieNumber the number of the serie that you want to add the points
  * [
  *     {x: new Date(timestamp), y: Float_value},
  *     {x: new Date(timestamp), y: Float_value}
  * ]
  **/
 function addDataPointsWithSerieNumber(values, serieNumber) {
     var dpsCollection = chart.options.data[serieNumber].dataPoints;
     for(var point in values) {
         dpsCollection.push(values[point]);
         if(dpsCollection.length > this.windowSize) {
             dpsCollection.shift();
         }
     }
     this.chart.render();
 }

 /**
  * Add the point to the chart
  * @param point
  * {x: new Date(timestamp), y: Float_value}
  */
    function addDataPoint(point) {
        var dpsCollection = chart.options.data[0].dataPoints;
        dpsCollection.push(point);
        if(dpsCollection.length > this.windowSize) {
            dpsCollection.shift();
        }
        this.chart.render();
    }

    function initPage(){
        var currentView = kubiModel.universe(0).time(last_timestamp);
        currentView.getRoot().then(function (root) {
            nunjucks.configure({autoescape: true});
            try {
                // init the graph

                nunjucks.renderString($("#ecosystem-template").html(), {ecosystem: root,autoRefresh:true,autoNow:true}, function (err, res) {
                    if (err) {
                        console.log(err);
                    }
                    $("#ecosystem").html(res);
                    var currentView = kubiModel.universe(0).time((new Date()).getTime());
                    currentView.getRoot().then(function (root) {
                        root.traversal().traverse(org.kubi.meta.MetaEcosystem.REF_DEVICES).withAttribute(org.kubi.meta.MetaDevice.ATT_NAME, "echo2")
                                .traverse(org.kubi.meta.MetaDevice.REF_PARAMETERS).withAttribute(org.kubi.meta.MetaParameter.ATT_NAME, "name").done().then(function (params) {
                                    var param = params[0];
                                    addDataPoint({x: new Date(param.now()), y: parseFloat(param.getValue())});
                                    console.log({x: new Date(param.now()), y: parseFloat(param.getValue())});
                                });
                    });
                });
            } catch(e){
                console.error(e);
            }



        });
    }

</script>
</body>
</html>