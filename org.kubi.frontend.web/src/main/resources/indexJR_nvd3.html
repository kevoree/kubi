<!DOCTYPE html>
<html>
<head>
    <script src="http://code.jquery.com/jquery-1.11.2.min.js"></script>
    <script src="nunjucks.js"></script>
    <script src="org.kubi.model-all.js"></script>
    <script src="org.kevoree.modeling.database.websocket.WebSocket.js"></script>
    <!--  for the second graph -->
    <link href="./nv.d3.css" rel="stylesheet" type="text/css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.2/d3.min.js" charset="utf-8"></script>
    <script src="./nv.d3.js"></script>

</head>
<body>
<a href="index.html">index</a>
<a href="indexJR.html">indexJR</a>
<a href="indexJR_nvd3.html">indexJR_nvd3.html</a>
<script id="ecosystem-template" type="text/x-handlebars-template">
    <h1>EcoSystem {{ecosystem.name}}</h1>
    <div class="body">
        <ul>
            {% asyncEach device in ecosystem.devices %}
            <li>{{device.name}} ({{device.version}})
                <ul>
                    {% asyncEach ff in device.functions %}
                    <li>
                        <button onclick="javascript:btclick('{{ff.now()}}','{{ff.uuid()}}','sayHello');">
                            {{ff.name}}
                        </button>
                    </li>
                    {% endeach %}
                </ul>
                <ul>
                    {% asyncEach param in device.parameters %}

                    <li>
                        <p>
                            {{param.name}}  -  {{param.value}}
                        </p>
                    </li>
                    {% endeach %}
                </ul>
            </li>
            {% endeach %}
        </ul>
        {{body}}
    </div>
</script>
<div id="ecosystem"></div>
<div id="chart1"></div>
<div id="execution-result"></div>


<script>
    var last_timestamp = (new Date()).getTime();
    var kubiModel = new org.kubi.KubiModel();
    function btclick(time, uuid, params) {
        kubiModel.universe(0).time(time).lookup(uuid).then(function (resolved) {
            resolved.exec(params, function (rpcRes) {
                $("#execution-result").html("Model based RPC result=" + rpcRes);
            });
        })
    }
    kubiModel.setContentDeliveryDriver(new org.kevoree.modeling.database.websocket.WebSocketClient("ws://" + location.host + "/cdn"));
    kubiModel.connect().then(function (e) {
        if (e) {
            console.error(e);
        } else {
            initGraph();
        }
    });
</script>

<script>
    var chart;
    var dataPoints = {};
    function initGraph(){
        var currentView = kubiModel.universe(0).time(last_timestamp);
        currentView.getRoot().then(function (root) {
            root.traversal().traverse(org.kubi.meta.MetaEcosystem.REF_DEVICES).done().then(function (devices){
                var d;
                for(d = 0; d< devices.length; d++)
                {
                    var device = devices[d];
                    // add a curb describing the device on the chart
                    chart.options.data.push({type: "line", showInLegend: true, name: device.getName(), dataPoints: []});
                    dataPoints[device.getName()]=[];
                    // add old data to the chart
                    device.traversal().traverse(org.kubi.meta.MetaDevice.REF_PARAMETERS).withAttribute(org.kubi.meta.MetaParameter.ATT_NAME, "name").done().then(function (params){
                        if (params.length != 0) {
                            var param = params[0];
                            param.jump(param.now()-1000).then(function (paramTimed){
                                param.parent().then(function (parent){
                                    addPreviousValues(paramTimed, parent.getName());
                                });
                            });
                        }
                    });
                }
            });
            /*root.traversal().traverse(org.kubi.meta.MetaEcosystem.REF_DEVICES).withAttribute(org.kubi.meta.MetaDevice.ATT_NAME, "echo2")
             .traverse(org.kubi.meta.MetaDevice.REF_PARAMETERS).withAttribute(org.kubi.meta.MetaParameter.ATT_NAME, "name").done().then(function (params) {
             if (params.length != 0) {
             var param = params[0];
             param.jump(param.now()-1000).then(function (paramTimed){
             addPreviousValues(paramTimed);
             });
             }
             });*/
        });
    }
    function addPreviousValues(paramTimed, deviceName){
        console.log("--", deviceName);
        if((paramTimed.now() > last_timestamp-30000) && (paramTimed.getValue()!= undefined)) {
            dataPoints[deviceName].push({x: new Date(paramTimed.now()), y: parseFloat(paramTimed.getValue())});
            console.log("---------",dataPoints);
            //addDataPointWithSerie({x: new Date(paramTimed.now()), y: parseFloat(paramTimed.getValue())}, deviceName);
            paramTimed.jump(paramTimed.now() - 1000).then(function (param1){
                addPreviousValues(param1, deviceName);
            });
        }
        else{
            var unsortedDataPoints = dataPoints[deviceName];
            var sortedDataPoints = [];
            for(var i=0;i<unsortedDataPoints.length;i++){
                sortedDataPoints.push(unsortedDataPoints.slice(unsortedDataPoints.length-i-1,unsortedDataPoints.length-i)[0])
            }
            addDataPointsWithSerieName(sortedDataPoints,deviceName);
            initPage();
            chart.render();
        }
    }
    function addDataPoints(values) {
        for(var serie in values) {
            var dpts = values[serie];
            var dpsCollection = chart.options.data[serie].dataPoints;
            for(var point in dpts) {
                dpsCollection.push(dpts[point]);
                if(dpsCollection.length > this.windowSize) {
                    dpsCollection.shift();
                }
            }
        }
        this.chart.render();
    }
    /**
     *Add a set of points to the chart in the data set number serieNumber
     *@param  value the set of points
     * @param serieNumber the number of the serie that you want to add the points
     * [
     *     {x: new Date(timestamp), y: Float_value},
     *     {x: new Date(timestamp), y: Float_value}
     * ]
     **/
    function addDataPointsWithSerieNumber(values, serieNumber) {
        var dpsCollection = chart.options.data[serieNumber].dataPoints;
        for(var point in values) {
            dpsCollection.push(values[point]);
            if(dpsCollection.length > this.windowSize) {
                dpsCollection.shift();
            }
        }
        this.chart.render();
    }
    /**
     *Add a set of points to the chart
     * @param  value the set of poins
     * @param serieName the name of the serie that you want to add the points
     * [
     *     {x: new Date(timestamp), y: Float_value},
     *     {x: new Date(timestamp), y: Float_value}
     * ]
     **/
    function addDataPointsWithSerieName(values, serieName) {
        var dpsCollection;
        var index;
        for(var d in chart.options.data){
            data = chart.options.data[d];
            if(data.name.equals(serieName)){
                dpsCollection = data.dataPoints;
                index = d;
            }
        }
        if(dpsCollection != null && index != null) {
            for (var point in values) {
                dpsCollection.push(values[point]);
                if (dpsCollection.length > this.windowSize) {
                    dpsCollection.shift();
                }
            }
        }
        else{
            console.error("Bad series name ",serieName, " : device not in the data set of the chart.");
        }
        this.chart.render();
    }
    /**
     * Add the point to the chart in the first set of data
     * @param point
     * {x: new Date(timestamp), y: Float_value}
     */
    function addDataPoint(point) {
        var dpsCollection = chart.options.data[0].dataPoints;
        dpsCollection.push(point);
        if(dpsCollection.length > this.windowSize) {
            dpsCollection.shift();
        }
        this.chart.render();
    }
    /**
     * Add the point to the chart
     * @param point
     * {x: new Date(timestamp), y: Float_value}
     * @param serie name
     *     the name of the chart where you want to add the point (should be the name of the device)
     */
    function addDataPointWithSerie(point, serie) {
        /*
        console.log("In dataPOintWithSerie .....",serie);
        if(dpsCollection != null && index!=null) {
            var dpsCollection = chart.options.data[index].dataPoints;
            dpsCollection.push(point);
            if (dpsCollection.length > this.windowSize) {
                dpsCollection.shift();
            }
        }
        else{
            console.error("Bad series name (=",serie ,") : device not in the data set of the chart.");
        }
        this.chart.render();*/
    }
    function initPage(){
        var currentView = kubiModel.universe(0).time(last_timestamp);
        currentView.getRoot().then(function (root) {
            nunjucks.configure({autoescape: true});
            try {
                // init the graph
                nunjucks.renderString($("#ecosystem-template").html(), {ecosystem: root,autoRefresh:true,autoNow:true}, function (err, res) {
                    if (err) {
                        console.log(err);
                    }
                    $("#ecosystem").html(res);
                    var currentView = kubiModel.universe(0).time((new Date()).getTime());
                    currentView.getRoot().then(function (root) {
                        root.traversal().traverse(org.kubi.meta.MetaEcosystem.REF_DEVICES).done().then(function (devices){
                            var d;
                            for(d = 0; d<devices.length ; d++){
                                var device = devices[d];
                                device.traversal().traverse(org.kubi.meta.MetaDevice.REF_PARAMETERS).withAttribute(org.kubi.meta.MetaParameter.ATT_NAME, "name").done().then(function (params) {
                                    var param = params[0];
                                    param.parent().then(function(parent){
                                        addDataPointWithSerie({x: new Date(param.now()), y: parseFloat(param.getValue())}, parent.getName());
                                    });
                                });
                            }
                        });
                    });
                });
            } catch(e){
                console.error(e);
            }
        });
    }
</script>


<script>
    // Wrapping in nv.addGraph allows for '0 timeout render', stores rendered charts in nv.graphs, and may do more in the future... it's NOT required
    var chart;
    var data;
    var randomizeFillOpacity = function() {
        var rand = Math.random(0,1);
        for (var i = 0; i < 100; i++) { // modify sine amplitude
            data[4].values[i].y = Math.sin(i/(5 + rand)) * .4 * rand - .25;
        }
        data[4].fillOpacity = rand;
        chart.update();
    };
    nv.addGraph(function() {
        chart = nv.models.lineChart()
                .options({
                    transitionDuration: 300
                    //useInteractiveGuideline: true
                })
        ;
        // chart sub-models (ie. xAxis, yAxis, etc) when accessed directly, return themselves, not the parent chart, so need to chain separately
        chart.xAxis
                .axisLabel("Time (s)")
                .tickFormat(d3.format(',.1f'))
                .staggerLabels(true)
        ;
        chart.yAxis
                .axisLabel('Voltage (v)')
                .tickFormat(d3.format(',.2f'))
        ;
        data = sinAndCos();
        console.log(chart.values);
        d3.select('#chart1').append('svg')
                .datum(data)
                .call(chart);
        nv.utils.windowResize(chart.update);
        return chart;
    });
    function sinAndCos() {
        var sin = [],
                sin2 = [],
                cos = [],
                rand = [],
                rand2 = []
                ;
        for (var i = 0; i < 100; i++) {
            sin.push({x: i, y: i % 10 == 5 ? null : Math.sin(i/10) }); //the nulls are to show how defined works
            sin2.push({x: i, y: Math.sin(i/5) * 0.4 - 0.25});
            cos.push({x: i, y: .5 * Math.cos(i/10)});
            rand.push({x:i, y: Math.random() / 10});
            rand2.push({x: i, y: Math.cos(i/10) + Math.random() / 10 })
        }
        return [
            {
                area: true,
                values: sin,
                key: "Sine Wave",
                color: "#ff7f0e",
                strokeWidth: 4,
                classed: 'dashed'
            },
            {
                values: cos,
                key: "Cosine Wave",
                color: "#2ca02c"
            },
            {
                values: rand,
                key: "Random Points",
                color: "#2222ff"
            },
            {
                values: rand2,
                key: "Random Cosine",
                color: "#667711",
                strokeWidth: 3.5
            },
            {
                area: true,
                values: sin2,
                key: "Fill opacity",
                color: "#EF9CFB",
                fillOpacity: .1
            }
        ];
    }
</script>
</body>

<style>
    body {

        display: block;
    }
    text {
        font: 12px sans-serif;
    }
    svg {
        display: block;
    }
    html, body, #chart1, svg {
        margin: 0px;
        padding: 0px;
        height: 100%;
        width: 100%;
    }
    .dashed {
        stroke-dasharray: 5,5;
    }
</style>

</html>